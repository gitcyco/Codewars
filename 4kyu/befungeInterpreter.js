// 4 kyu Befunge Interpreter
//
// Esoteric languages are pretty hard to program, but it's fairly interesting to write interpreters for them!
//
// Your task is to write a method which will interpret Befunge-93 code!
// Befunge-93 is a language in which the code is presented not as a series of instructions, but as instructions
// scattered on a 2D plane; your pointer starts at the top-left corner and defaults to moving right through the code.
// Note that the instruction pointer wraps around the screen!
// There is a singular stack which we will assume is unbounded and only contain integers.
// While Befunge-93 code is supposed to be restricted to 80x25, you need not be concerned with code size.
// Befunge-93 supports the following instructions (from Wikipedia):
//
//     0-9 Push this number onto the stack.
//     + Addition: Pop a and b, then push a+b.
//     - Subtraction: Pop a and b, then push b-a.
//     * Multiplication: Pop a and b, then push a*b.
//     / Integer division: Pop a and b, then push b/a, rounded down. If a is zero, push zero.
//     % Modulo: Pop a and b, then push the b%a. If a is zero, push zero.
//     ! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero.
//     ` (backtick) Greater than: Pop a and b, then push 1 if b>a, otherwise push zero.
//     > Start moving right.
//     < Start moving left.
//     ^ Start moving up.
//     v Start moving down.
//     ? Start moving in a random cardinal direction.
//     _ Pop a value; move right if value = 0, left otherwise.
//     | Pop a value; move down if value = 0, up otherwise.
//     " Start string mode: push each character's ASCII value all the way up to the next ".
//     : Duplicate value on top of the stack. If there is nothing on top of the stack, push a 0.
//     \ Swap two values on top of the stack. If there is only one value, pretend there is an extra 0 on bottom of the stack.
//     $ Pop value from the stack and discard it.
//     . Pop value and output as an integer.
//     , Pop value and output the ASCII character represented by the integer code that is stored in the value.
//     # Trampoline: Skip next cell.
//     p A "put" call (a way to store a value for later use). Pop y, x and v, then change the character at the position (x,y) in the program to the character with ASCII value v.
//     g A "get" call (a way to retrieve data in storage). Pop y and x, then push ASCII value of the character at that position in the program.
//     @ End program.
//      (i.e. a space) No-op. Does nothing.
//
// The above list is slightly modified: you'll notice if you look at the Wikipedia page that we do not use the user input instructions and dividing by zero simply yields zero.
//
// Here's an example:
//
// >987v>.v
// v456<  :
// >321 ^ _@
//
// will create the output 123456789.
//
// So what you must do is create a function such that when you pass in the Befunge code, the function returns the output that would be generated by the code. So, for example:
//
// "123456789".equals(new BefungeInterpreter().interpret(">987v>.v\nv456<  :\n>321 ^ _@")
//
// This test case will be added for you.
//
// Answer:
function interpret(input) {
  const stack = [];
  let code = input.split("\n");
  let maxX = code.reduce((a, e) => (e.length > a ? e.length : a), 0);
  let maxY = code.length;
  let dir = ">";
  let curX = 0;
  let curY = 0;
  let mode = 0; // 0 == normal code, 1 == string mode
  let a, b, x, y, v;
  let output = "";
  code = code.map((e) => e.padEnd(maxX, " ")).map((e) => e.split(""));

  // Reset maxX and maxY to 0 based indexing
  maxX--;
  maxY--;

  while (code[curY][curX] !== "@") {
    // Are we in string mode? If so, start pushing chars to stack until next "
    if (mode) {
      if (code[curY][curX] === '"') {
        mode = 0;
      } else {
        stack.push(String(code[curY][curX]).charCodeAt(0));
      }
      // Is the instruction a number from 0-9?
    } else if (/[0-9]/gi.test(code[curY][curX])) {
      //  0-9 Push this number onto the stack.
      stack.push(+code[curY][curX]);
    } else {
      switch (code[curY][curX]) {
        // " Start string mode: push each character's ASCII value all the way up to the next "
        case '"':
          mode = 1;
          break;
        //  (i.e. a space) No-op. Does nothing
        case " ":
          break;
        // > Start moving right
        case ">":
          dir = ">";
          break;
        // v Start moving down
        case "v":
          dir = "v";
          break;
        // < Start moving left
        case "<":
          dir = "<";
          break;
        // ^ Start moving up
        case "^":
          dir = "^";
          break;
        // ? Start moving in a random cardinal direction
        case "?":
          dir = ranDir();
          break;
        // + Addition: Pop a and b, then push a+b
        case "+":
          a = +stack.pop();
          b = +stack.pop();
          stack.push(a + b);
          break;
        // - Subtraction: Pop a and b, then push b-a
        case "-":
          a = +stack.pop();
          b = +stack.pop();
          stack.push(b - a);
          break;
        // * Multiplication: Pop a and b, then push a*b
        case "*":
          a = +stack.pop();
          b = +stack.pop();
          stack.push(a * b);
          break;
        // / Integer division: Pop a and b, then push b/a, rounded down. If a is zero, push zero
        case "/":
          a = +stack.pop();
          b = +stack.pop();
          if (a == 0) stack.push(0);
          else Math.floor(stack.push(b / a));
          break;
        // % Modulo: Pop a and b, then push the b%a. If a is zero, push zero
        case "%":
          a = +stack.pop();
          b = +stack.pop();
          if (a == 0) stack.push(0);
          else stack.push(b % a);
          break;
        // ! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero
        case "!":
          a = +stack.pop();
          if (a === 0) stack.push(1);
          else stack.push(0);
          break;
        // ` (backtick) Greater than: Pop a and b, then push 1 if b>a, otherwise push zero
        case "`":
          a = stack.pop();
          b = stack.pop();
          stack.push(b > a ? 1 : 0);
          break;
        // _ Pop a value; move right if value = 0, left otherwise
        case "_":
          console.log("choose", stack);
          a = stack.pop();
          if (a == 0) {
            dir = ">";
          } else {
            dir = "<";
          }
          break;
        // | Pop a value; move down if value = 0, up otherwise
        case "|":
          a = +stack.pop();
          if (a === 0) {
            dir = "v";
          } else {
            dir = "^";
          }
          break;
        // : Duplicate value on top of the stack. If there is nothing on top of the stack, push a 0
        case ":":
          if (stack.length === 0) stack.push(0);
          else stack.push(stack[stack.length - 1]);
          break;
        // \ Swap two values on top of the stack. If there is only one value, pretend there is an extra 0 on bottom of the stack
        case "\\":
          if (stack.length === 1) {
            stack.push(0);
          } else {
            a = stack.pop();
            b = stack.pop();
            stack.push(a);
            stack.push(b);
          }
          break;
        // $ Pop value from the stack and discard it
        case "$":
          stack.pop();
          break;
        // . Pop value and output as an integer
        case ".":
          if (stack.length > 0) {
            a = +stack.pop();
            output += a.toString();
          }
          break;
        // , Pop value and output the ASCII character represented by the integer code that is stored in the value
        case ",":
          a = +stack.pop();
          output += String.fromCharCode(a);
          break;
        // # Trampoline: Skip next cell
        case "#":
          [curX, curY] = move(curX, curY, dir, maxX, maxY);
          break;
        // p A "put" call (a way to store a value for later use). Pop y, x and v, then change the character
        // at the position (x,y) in the program to the character with ASCII value v
        case "p":
          y = +stack.pop();
          x = +stack.pop();
          v = +stack.pop();
          code[y][x] = String.fromCharCode(v);
          break;
        // g A "get" call (a way to retrieve data in storage).
        // Pop y and x, then push ASCII value of the character at that position in the program
        case "g":
          y = +stack.pop();
          x = +stack.pop();
          stack.push(code[y][x].charCodeAt(0));
          break;
      }
    }
    // Advance the instruction pointer
    [curX, curY] = move(curX, curY, dir, maxX, maxY);
  }

  return output;
}

// Get a random direction
const ranDir = () => [">", "<", "^", "v"][Math.floor(Math.random() * 4)];

// Advance the instruction pointer
const move = (curX, curY, dir, maxX, maxY) => {
  switch (dir) {
    case ">":
      curX = curX === maxX ? 0 : curX + 1;
      break;
    case "v":
      curY = curY === maxY ? 0 : curY + 1;
      break;
    case "<":
      curX = curX === 0 ? maxX : curX - 1;
      break;
    case "^":
      curY = curY === 0 ? maxY : curY - 1;
      break;
  }
  return [curX, curY];
};
